<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go并发编程</title>
    <url>/posts/2/</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/lovevivi121/PicGo/img/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.png"></p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>开发模板</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h1 id="开发流程："><a href="#开发流程：" class="headerlink" title="开发流程："></a>开发流程：</h1><ol>
<li>修改公告 在source&#x2F;_data&#x2F;butterfly.yml中找到并修改</li>
<li>添加文章 在source&#x2F;_posts 下面的对应分类中copy本模板然后修改内容即可</li>
<li>添加分类 在写文章的时候写上对应分类即可</li>
<li>添加图片 首先添加到图床中，然后将链接放上去</li>
<li>上传 运行命令 <code>hexo s</code>（本地预览），<code>hexo clean</code>（清除生成文件），<code>hexo g</code>（生成网页）,<code>hexo deploy</code>（部署）</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>9.25-学习计算机网络MAC层、操作系统X86架构</title>
    <url>/posts/3/</url>
    <content><![CDATA[<ol>
<li>x86架构<ol>
<li>需求<ol>
<li>做生意要开放的营商环境，所以操作系统也需要一个统一的开放的架构</li>
</ol>
</li>
<li>计算机的工作模式是什么样的？</li>
<li>cpu和内存是如何配合工作的？<ol>
<li>cpu包裹三个部分，运算、数据、控制单元</li>
<li>从之后面就讲到了内存的数据和总线的位数有无统一标准？没有标准操作系统很难办，因为操作系统作为软件层没办法实现通用的运算逻辑</li>
</ol>
</li>
<li>由此出现了X86架构<ol>
<li>基本概念<ol>
<li>英特尔的技术是行业的开放事实标准。由于这个系列开端于 8086，因此称为 x86 架构。</li>
</ol>
</li>
<li>8086处理器<ol>
<li>数据单元<ol>
<li>内部有8个16位的通用寄存器，分别是AX BX CX DX SP BP SI DI 用于暂存数据</li>
<li>AX BX CX DX 可以分成两个8位的寄存器使用，分别是AH AL BH BL etc，这样长短数据都可以暂存了</li>
</ol>
</li>
<li>控制单元<ol>
<li>IP寄存器就是指令指针寄存器，指向代码段中下一条指令的位置。cpu会根据它来不断地将指令从内存的代码段中加载到cpu的指令队列中，然后交给运算单元执行。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>计算机网络<ol>
<li>MAC层<ol>
<li>基本概念<ol>
<li>MAC层即媒体访问控制，数据链路层。</li>
</ol>
</li>
<li>解决的主要问题<ol>
<li>这个包是发给谁的？谁该接收？</li>
<li>如果大家都在发，谁先发，谁后发？会不会混乱？</li>
<li>如果发送的时候出现错误怎么办？</li>
<li>一个广播的网络里面接入了N台机器，怎么直到每个MAC地址是谁？</li>
<li>能否直到目标MAC地址就将数据包转到对应口的机器，从而不广播呢？</li>
</ol>
</li>
<li>解决方案<ol>
<li>针对问题一，通过MAC地址来确定发给谁，谁接收。有了目标MAC地址和源MAC地址，数据包在链路上广播，MAC的网卡才能发现这个包是给他的。MAC的网卡把包收进来，然后打开IP包交给网络层。</li>
<li>针对第二个问题，学名叫多路访问，有很多算法可以解决多路访问问题<ol>
<li>信道划分，即分多个车道，每个车道中的车你走你的，我走我的</li>
<li>轮流协议，就像车今天单号出行，明天双号出行，轮着来</li>
<li>随机接入协议，有事儿先出门，发现特堵，就回去，错峰再出行（以太网）</li>
</ol>
</li>
<li>针对问题三，对于以太网，MAC网络包中的最后4Byte是CRC循环冗余检测，通过XOR异或算法来计算整个包是否在发送过程中出现错误。</li>
<li>针对第四个问题，MAC层使用了ARP协议，也就是已知IP地址，求MAC地址的协议。具体机制是发送方“吼”一声，发送一个广播包，谁是这个IP谁来回答，为了避免每次都用ARP请求，机器会进行ARP缓存，并且过一段时间过期更新。<ol>
<li>ARP报文</li>
</ol>
</li>
<li>针对第五个问题，有一个MAC层设备称为交换机，交换机会记住第一次广播吼的MAC地址，形成一个转发表，这样以后的目的地址是该MAC地址的就直接发送到这个口即可，不必广播了。</li>
</ol>
</li>
<li>MAC网络包格式<ol>
<li>前6byte是目标MAC地址，再是6byte的源MAC地址，然后是2byte的类型（0800表示IP数据报，0806表示ARP请求和应答），然后是46－1500byte的数据，最后是4byteCRC循环冗余校验码</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-基本架构</title>
    <url>/posts/4/</url>
    <content><![CDATA[<h1 id="大体上MySQL可以分为Server层和引擎层两个部分"><a href="#大体上MySQL可以分为Server层和引擎层两个部分" class="headerlink" title="大体上MySQL可以分为Server层和引擎层两个部分"></a>大体上MySQL可以分为Server层和引擎层两个部分</h1><h1 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h1><ul>
<li><p>Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><ul>
<li>基本概念<ul>
<li>当客户端连接到数据库上的时候，首先接待的便是连接器，连接器负责跟客户端建立连接，获取权限，维持和管理连接。</li>
</ul>
</li>
<li>连接流程<ul>
<li>连接的命令如下<code>-h$ip -p$port -u$user -p</code> 接着输入密码。完成TCP握手后连接器就会开始身份认证。如果用户或者密码不对就会报<code>Access denied for user</code>错误，客户端结束运行。如果认证通过，接下来连接器会到权限表里面获取当前用户的所有权限。之后该连接的所有权限判断都依据当前获取的权限，意味着即使权限被修改了，也需要重新连接才能使用新的权限。</li>
<li>完成连接后，如果没有操作该连接便会进入空闲状态，可在show processlist里面查看连接的状态。如果连接超过wait_timeout时间没有动作，默认是8小时，则会将连接断开，如果此时再发起请求将会报<code>Lost connection to MySQL server during query</code>错误。</li>
</ul>
</li>
<li>长连接与短链接<ul>
<li>基本概念<ul>
<li>长连接是指如果客户端一直有请求则一直使用该连接。短连接是指每次执行过很少请求后就断开连接，下次查询再重新连接。由于连接过程复杂，所以推荐使用长连接。</li>
</ul>
</li>
<li>长连接的问题与解决方案<ul>
<li>问题提出<ul>
<li>MySQL执行过程中使用的内存是在连接内部的，这些资源会在连接断开的时候才释放。如果使用长连接，积累过多了会导致内存暴涨，这个时候系统会强行kill连接，表现出来就是MySQL异常重启了。</li>
</ul>
</li>
<li>解决方案<ul>
<li>一个是定期断开长连接，或者执行了一个占用内存大的查询后，断开连接并重连。</li>
<li>另一个是5.7版本后可以使用<code>mysql_reset_connection</code>重新初始化连接资源,不用断开连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ul>
<li>基本概念<ul>
<li>建立连接后执行逻辑会来到查询缓存。MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。但是查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</li>
</ul>
</li>
<li>按需使用<ul>
<li>MySQL 提供了“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：mysql&gt; select SQL_CACHE * from T where ID&#x3D;10；</li>
<li>MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</li>
</ul>
</li>
</ul>
<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><ul>
<li>基本概念<ul>
<li>如果没有命中查询缓存，则接下来要开始真正执行语句了。首先MySQL需要知道你要做什么，因此需要对SQL语句做解析。</li>
</ul>
</li>
<li>语句解析分为了词法分析和语法分析<ul>
<li>词法分析<ul>
<li>分析的是SQL语句的字符串中分别是什么，代表什么。比如select就标识为查询语句，ID识别为列ID等</li>
</ul>
</li>
<li>语法分析<ul>
<li>是用来判断SQL语句是否满足MySQL语法，如果不满足则报You have an error in your SQL syntax错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><ul>
<li>在开始执行前，还要经过优化器处理。优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多个表关联（join）时，决定各表的连接顺序，这些都会导致执行效率的不同。</li>
</ul>
<h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><ul>
<li>接下来就是进入执行器阶段，开始执行语句。</li>
<li>基本流程<ul>
<li>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
<li>比如我们要查询表 T 中ID为10的数据，并且ID 字段没有索引，那么执行器的执行流程是这样的：1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
<li>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</li>
<li>在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ul>
<li>什么是存储引擎？<ul>
<li>存储引擎层负责数据的存储和提取，直接与磁盘交互部分。页是存储引擎读写数据的最小单位，一个页里可以有一条或多条表记录。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎，而 InnoDB 是 MySQL 中唯一能够完整支持事务特性的存储引擎。你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table语句中使用 engine&#x3D;memory, 来指定使用内存引擎创建表。</li>
</ul>
</li>
<li>什么是随机 IO 和顺序 IO？<ul>
<li>磁盘读写数据的两种方式。随机 IO 需要先找到地址，再读写数据，每次拿到的地址都是随机的。而顺序 IO，由于地址是连贯的，找到地址后，一次可以读写许多数据，效率比较高。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
